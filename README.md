# Extreme ECS Programming (in GoLang)

This repository exists to explore building an Entity Component System in Go.

Each branch is an orphan containing an attempt.

## The Road So Far

### [One](../../tree/one)

My first attempt didn't get so far. Coasting on memory of reading blog posts, I
dove in and tried to scale Abstraction mountain. This went about as well as
you'd expect for a low level character. Fortunately I only spent about an hour
on this attempt.

### [Two](../../tree/two)

With the sting of death fresh in my nerves, I went back to the blog posts. I
picked one that seemed ruthlessly simple; in fact I picked exactly BECAUSE I
could already see some of its limitations.

This turned out to be a good choice, since what I was really lacking in attempt
one was any developed "muscles" for things like:
- terminal manipulation
- event handling
- what even is a good boundary to draw around a `System`?

Attempt two ended up being "playable":
- single player, random rolled stats
- a room outline
- AIs (demons) keep spawning, also with random rolled stats
  - spawn chance is a 1/N (where N is the number of combatants)

Meta progress:
- I plan to re-use parts of Two's code for Three; in particular, the drudgery
  of Yet Another Point Struct
- in Three I plan to start with the rendering system first rather than from the
  movement/combat system as I did with Two

### [Three](../../tree/three)

Feeling exhilarated from yesterday's progress, I took a day to focus on
building a [home](../../tree/home):

- `internal/point/point.go`: a cleaned up version of Two's `main.Point` for re-use.
- `internal/view/grid.go`: a `Point` + `termbox.Cell` structure, called `Grid`,
  with some of the rendering code from Two for re-use: it can copy one grid
  into another (centering or clamping as needed), and it can write a string
  into the grid (aligned left, center, or right).
- `internal/view/view.go`: consolidates most of the termbox code from Two into
  `View` which provides: an event polling loop, key event channel, and
  rendering system based on a `Grid`, header, footer, and logs.
- `internal/ecs/core.go`: defines the `Core` of an ECS, which you can embed
  into e.g. `main.World` struct. I'm coming to understand that this might be
  called an ["EntityManager" by the 'RDBMS Beta' interpretation][es-beta].
- `internal/ecs/entity.go`: provides what the [Beta interpretation][es-beta]
  might call a "MetaEntity": a convenience wrapper/reference to an entity for
  use outside of the ECS itself (e.g. by your main wiring code).

The actual "game" this time around is more demo: it statically renders what was
originally intended to be a "snake", but turned out to be more of a "hallway
system" since it's allowed to double back on itself.

#### [Three Prime](../../tree/three_prime)

Not being satisfied with my lovely new home, I set out to explore more: I
wanted to put my "not-quite-a-snake" in a "room", and experiment with
representing walls using compact tiles for a change. That may have worked, but
I also decided that boring straight-walled rooms were so yesterday, and instead
set out to draw a "permuted" room.

Well one thing lead to another, and before I knew it dusk was setting in as I
was trying to debug a complex digger that used an engineered markov transition
table to control displacement within a "toroidal" space... I never got it out
of "slice index range error panic" hell, but the partial result is still
interesting enough for post-mortem (I did end up adding dot product to my
2-vectors after all...)

### [Four](../../tree/four)

Decided to continue focusing on home improvements for now, especially since I
keep wrestling with debugging the view layer that I keep carrying along. Didn't
reach full satisfaction with it today, but I did at least get Two's world
ported over to it:

- many improvements to the point package, including a box defined by a top-left
  and bottom-right corners
- added iteration support to the ECS
- added a skeleton main.go inside the ECS module for faster start-over
- started reworking the view layer to suck less; learned a lot more about how I
  wish termbox was different (mostly simpler and more low level...)

### [Five](../../tree/five)

Finished off the view work, I now have it in a better place. I now have a
decent internal grudge list against termbox, and look forward excitedly to a
better/simpler/more-low-level alternative.

The two big items:
- added a markov transition table package: it allows you to markov chain
  through any ECS's entity space!
- ported forward Four's world to the new view code, and started using colors!
  - player and enemy colors now darken with lost HP
  - the floor and walls now have a randomized texture generated by colors
    chosen from a markov table
- oh right, and corpses now stick around; a great jumping off point for
  things to come!

And here's some other minor notes:
- added view support for merging into terminal grid cells; e.g. BG color
  provided by one update, glyph by another
- finished the view layer refactor, now things work a lot better, including
  resize works properly!
- entity iteration improved, and simplified in implementation detail
- entity references got way more useful
- iterated on the skeleton main.go for new view situation

### [Six](../../tree/six)

Today I dove back into the depths of ECS land. Having glimpsed possibilities
when reading [about the Beta approach][es-beta], and being plussed by how well
the markov table part went, I set out to build a "body" system:
- no more "arbitrary" Str, Def, Dex, and Luck; instead each world entity can have a body
- a body is itself an ECS composed of body parts; each body part has hp, a
  damage rating, and an armor rating
- the body parts exist in a hierarchical relation ship, such that if your arm
  is destroyed, so is your hand; this makes it possible to kill by destroying
  the head or torso
- severed body parts now drop into the world as separate item entities
- death now happens when you're "disembodied": when all body parts have dropped
  into the world, leaving an entity's body empty

For bonus, I made it so that if your head is still intact (i.e. you were killed
by torso destruction), then you get to continue on as a spirit for 5 turns.
Spirits can still collide, but since combat is based on presence of a body, no
damage happens (this happens to enemies as well of course).

Combat sub-targets are chosen automatically for you, but as soon as I level up
the view controller enough to support it, I'll add a mini-game allowing the
player to choose (e.g. to attack a leg, instead of going for the kill).

Next up I have plans for all those spare body parts... also maybe reclaim
something from destroyed body parts (e.g. the remaining damage/armor points on
whatever body part(s) you destroy)...

### [Seven](../../tree/seven)

Seven is an auspicous time to start over; now it's starting to look a lot more
like a base of data!

So yesterday's adventure got really bogged down in debugging land: all of my
inline relation and graph management code in the main package turned out to be
way more brittle than you'd hope.

Today I started out on a new orphan branch writing an ECS again from scratch!
Some high points:
- entity ids now have an explicit type, no longer just an `int`
- lifecycle hooks are now provided for data allocation, creation, and destruction
- a relational core extension is provided: its also a core, and its entities
  decribe relations between two other cores (maybe the same ones)
- the case of an "auto-relation" can further be upgraded to a graph relation;
  this is just a relational core where both the A and B cores are the same;
  currently not much exciting other than a `Roots` and `Leaves` method have
  been implemented.

I was able to get through that initial re-implementation in about 5 hours, I
then spent the next 5 hours porting Six to the new ECS engine. Needless to say,
it's working much better:
- the collision system is now just a relation table...
- ...so it'd be possible to use it to store a per-round damage / kill data as
  well
- I ported the markov table, but there's some consideration to be given to
  could it be "just" a relational table? Probably, but the current markov table
  is likely more space efficient than doing it that way.

I'm excited for: Eight: I'll either work further down to deepen the body
system, or expand out and start adding an agro table... only time will tell!

### [Eight](../../tree/eight)

Refactoring my way towards anger management:
- so progress on the ECS core:
  - Relation has now been much more tested and works well
  - Graph learned how to do DFS and CoDFS traversal
  - Cursor grew up, now supports indices
  - Cores now support generic create/destroy hooks
  - Relation uses those hooks to destroy orphaned relations...
  - ...and to provide optional cascading destroy
  - Core now plays it close to the chest
  - there's test coverage.

And for all that refactoring, the main game now:
- has an "agro" relation, which will cause the ai to chase the thing it hates most
- a "goal" relation which the ai will chase if it's got nothing to hate
- if ai doesn't have a goal, it picks a random non-combatant collidable
- since there's not yet any source of agro (i.e. damage should, maybe kills
  too), that's it

So in net: the AIs now mill around and kill each other, while the player can
play it safe from the edge; Whew!

### [Nine](../../tree/nine)

Small improvements and completing things:

- ecs progress:
  - several small fixes and improvements to Relation and friends
  - some parts got more debug friendly (fmt.Stringer implementations)
- world progress:
  - closed the agro loop: damage deals agro
  - added ai goal unsticking so that they stop getting stuck on the wall
    indefinitely
  - move generation decoupled from move applying; this leaves room for more
    mature move resolution strategies than first-one-wins
  - many cleanups and improvements to control flow

### [Ten](../../tree/ten)

Prompts, Interaction, and Combat:

- ECS progress:
  - improved where function convention
  - made Update's set function more useful/consistent
  - more minor conveniences

- Game Progress:
  - continued to improve the move processing
  - added more body parts (legs and arms now have an upper and lower part)
  - reworked the combat system to be less tedious:
    - potential damage is now `Round(dmg * rating * randBetween(0.5, 1.0))`, where:
    - `dmg` is the attacking part's damage score
    - `rating` is `srcHPRating / targHPRating`
    - `rand` is a random number in the internal `[0.5, 1.0)`
    - each `HPRating` is a hierarchical average rating of `hp/maxHP` from the
      attacking part all the way up its control path (i.e. rating compounding
      goes down for damage along any upstream part)
    - after potential damage, comes armor mitigation
    - misses are no longer a thing; may bring them back at some point once
      movement is taken into account during combat
  - started sketching an item interaction system:
    - spent most of my time building out a menu-based prompt system
    - body remains can now be looted for armor and damage points

- Misc:
  - added a `moremath.Round` utility

### [Eleven](../../tree/eleven)

Getting more out of your remains (but be quick!)

Today's focus was on the game, such as it is; no progress made in ECS land
itself:
- completed the item interaction system
- the first interaction is integrating a body part's armor and damage points
  into your own; doing so consumes a turn
- AI can now use items (and it prefers to do so when choosing a goal)
  - it uses the same prompting system that the user does, choosing randomly
- body remains now decay rapidly; also spirit duration is now coupled to the
  head from whence it came!
- added standard rogue-like vikeys
- added a quick hack to "phase" the palyer out of the collision system, mostly
  because this aids developing since I can just "phase out, and let the enemies
  have at it" for a while to see how things play out

[es-beta]: http://entity-systems.wikidot.com/rdbms-beta
