# Extreme ECS Programming (in GoLang)

This repository exists to explore building an Entity Component System in Go.

Each branch is an orphan containing an attempt.

## The Road So Far

### [One](../../tree/one)

My first attempt didn't get so far. Coasting on memory of reading blog posts, I
dove in and tried to scale Abstraction mountain. This went about as well as
you'd expect for a low level character. Fortunately I only spent about an hour
on this attempt.

### [Two](../../tree/two)

With the sting of death fresh in my nerves, I went back to the blog posts. I
picked one that seemed ruthlessly simple; in fact I picked exactly BECAUSE I
could already see some of its limitations.

This turned out to be a good choice, since what I was really lacking in attempt
one was any developed "muscles" for things like:
- terminal manipulation
- event handling
- what even is a good boundary to draw around a `System`?

Attempt two ended up being "playable":
- single player, random rolled stats
- a room outline
- AIs (demons) keep spawning, also with random rolled stats
  - spawn chance is a 1/N (where N is the number of combatants)

Meta progress:
- I plan to re-use parts of Two's code for Three; in particular, the drudgery
  of Yet Another Point Struct
- in Three I plan to start with the rendering system first rather than from the
  movement/combat system as I did with Two

### [Three](../../tree/three)

Feeling exhilarated from yesterday's progress, I took a day to focus on
building a [home](../../tree/home):

- `internal/point/point.go`: a cleaned up version of Two's `main.Point` for re-use.
- `internal/view/grid.go`: a `Point` + `termbox.Cell` structure, called `Grid`,
  with some of the rendering code from Two for re-use: it can copy one grid
  into another (centering or clamping as needed), and it can write a string
  into the grid (aligned left, center, or right).
- `internal/view/view.go`: consolidates most of the termbox code from Two into
  `View` which provides: an event polling loop, key event channel, and
  rendering system based on a `Grid`, header, footer, and logs.
- `internal/ecs/core.go`: defines the `Core` of an ECS, which you can embed
  into e.g. `main.World` struct. I'm coming to understand that this might be
  called an ["EntityManager" by the 'RDBMS Beta' interpretation][es-beta].
- `internal/ecs/entity.go`: provides what the [Beta interpretation][es-beta]
  might call a "MetaEntity": a convenience wrapper/reference to an entity for
  use outside of the ECS itself (e.g. by your main wiring code).

The actual "game" this time around is more demo: it statically renders what was
originally intended to be a "snake", but turned out to be more of a "hallway
system" since it's allowed to double back on itself.

#### [Three Prime](../../tree/three_prime)

Not being satisfied with my lovely new home, I set out to explore more: I
wanted to put my "not-quite-a-snake" in a "room", and experiment with
representing walls using compact tiles for a change. That may have worked, but
I also decided that boring straight-walled rooms were so yesterday, and instead
set out to draw a "permuted" room.

Well one thing lead to another, and before I knew it dusk was setting in as I
was trying to debug a complex digger that used an engineered markov transition
table to control displacement within a "toroidal" space... I never got it out
of "slice index range error panic" hell, but the partial result is still
interesting enough for post-mortem (I did end up adding dot product to my
2-vectors after all...)

### [Four](../../tree/four)

Decided to continue focusing on home improvements for now, especially since I
keep wrestling with debugging the view layer that I keep carrying along. Didn't
reach full satisfaction with it today, but I did at least get Two's world
ported over to it:

- many improvements to the point package, including a box defined by a top-left
  and bottom-right corners
- added iteration support to the ECS
- added a skeleton main.go inside the ECS module for faster start-over
- started reworking the view layer to suck less; learned a lot more about how I
  wish termbox was different (mostly simpler and more low level...)

### [Five](../../tree/five)

Finished off the view work, I now have it in a better place. I now have a
decent internal grudge list against termbox, and look forward excitedly to a
better/simpler/more-low-level alternative.

The two big items:
- added a markov transition table package: it allows you to markov chain
  through any ECS's entity space!
- ported forward Four's world to the new view code, and started using colors!
  - player and enemy colors now darken with lost HP
  - the floor and walls now have a randomized texture generated by colors
    chosen from a markov table
- oh right, and corpses now stick around; a great jumping off point for
  things to come!

And here's some other minor notes:
- added view support for merging into terminal grid cells; e.g. BG color
  provided by one update, glyph by another
- finished the view layer refactor, now things work a lot better, including
  resize works properly!
- entity iteration improved, and simplified in implementation detail
- entity references got way more useful
- iterated on the skeleton main.go for new view situation

### [Six](../../tree/six)

Today I dove back into the depths of ECS land. Having glimpsed possibilities
when reading [about the Beta approach][es-beta], and being plussed by how well
the markov table part went, I set out to build a "body" system:
- no more "arbitrary" Str, Def, Dex, and Luck; instead each world entity can have a body
- a body is itself an ECS composed of body parts; each body part has hp, a
  damage rating, and an armor rating
- the body parts exist in a hierarchical relation ship, such that if your arm
  is destroyed, so is your hand; this makes it possible to kill by destroying
  the head or torso
- severed body parts now drop into the world as separate item entities
- death now happens when you're "disembodied": when all body parts have dropped
  into the world, leaving an entity's body empty

For bonus, I made it so that if your head is still intact (i.e. you were killed
by torso destruction), then you get to continue on as a spirit for 5 turns.
Spirits can still collide, but since combat is based on presence of a body, no
damage happens (this happens to enemies as well of course).

Combat sub-targets are chosen automatically for you, but as soon as I level up
the view controller enough to support it, I'll add a mini-game allowing the
player to choose (e.g. to attack a leg, instead of going for the kill).

Next up I have plans for all those spare body parts... also maybe reclaim
something from destroyed body parts (e.g. the remaining damage/armor points on
whatever body part(s) you destroy)...

[es-beta]: http://entity-systems.wikidot.com/rdbms-beta
